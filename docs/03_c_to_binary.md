# C 코드 → RISC-V 실행파일까지 (툴체인 흐름 요약)

## 1. 전체 흐름

C 소스는 대략 이렇게 변환된다:

```text
prog.c  ──(컴파일)──▶  prog.s   ──(어셈블)──▶  prog.o   ──(링크)──▶  prog(ELF 실행파일)
       (C → RISC-V ASM)        (ASM → 기계어)          (여러 .o + 라이브러리 합치기)
```

실제로는 `gcc`가 **컴파일 + 어셈블 + 링크**를 한 번에 해주는 경우가 많다.

---

## 2. 한 번에 실행파일 만들기

```bash
riscv32-corev-elf-gcc -O1 -g prog.c -o prog
```

- `-O1` : 최적화 레벨 1 (간단한 최적화)
- `-g`  : 디버깅 정보 포함 (gdb, objdump에서 소스 라인 확인 가능)
- 결과: `prog` 라는 **ELF 실행파일** 생성  
  → 안에는 RISC-V 명령어(기계어) + 심볼/디버그 정보가 들어 있음.

---

## 3. 오브젝트 파일까지만 만들기

```bash
riscv32-corev-elf-gcc -O1 -g -c prog.c -o prog.o
```

- `-c` : **compile + assemble 까지만**, 링크는 하지 않음
- 결과: `prog.o` (오브젝트 파일, 아직 단독 실행은 안 됨)
  - 섹션: `.text`(코드), `.data`, `.bss`, 심볼 정보 등 포함

여러 개의 `.o`를 나중에 한 번에 링크해서 최종 실행파일을 만들 수 있다.

---

## 4. 어셈블리로 들여다보기 (objdump)

```bash
riscv32-corev-elf-objdump -S prog.o
```

- `-S` : C **소스 코드 + 어셈블리**를 같이 보여줌
- 이걸로:
  - C 한 줄이 어떤 RISC-V 명령어 시퀀스로 바뀌는지 확인 가능
  - 컴파일러가 레지스터를 어떻게 배치했는지(T, S, A 레지스터) 볼 수 있음

예:
```text
00000000 <func>:
   0:  00050793   addi a5,a0,0
   4:  00178793   addi a5,a5,1
   8:  00078513   addi a0,a5,0
   c:  00008067   ret
```



